function solution(n, m) {
  let answer = [];
  //최대공약수 구하기
  let max = 0;
  for (let i = 1; i <= m; i++) {
    //반복문으로 제시된 수의 나머지값 0인 i값을 max에 넣는다 -> 가장 큰 수만 max에 남게 됨.
    if (n % i === 0 && m % i === 0) {
      max = i;
    }
  }
  //최소공배수 구하기(두 수를 곱해서 최대 수를 정해놓고 반복문을 실행)
  let min = 0;
  for (let i = m; i <= m * n; i += m) {
    if (i % n === 0) {
      min = i;
      break; //가장 작은 공배수를 구해야하니까 반복문 중단
    }
  }
  return [max, min];
}

//유클리드 호제법 : 최대공약수 구하기 위한 알고리즘 공식
//두가지 수 중 큰 수를 작은 수를 나눴을 때 나머지 값이 0이 되면 나눴던 작은 수가 최대공약수가 된다.
//나머지 값이 0이 되지 않는다면 작은 수가 큰 수가 되고, 나머지 값이 작은 수가 된다.
//이 방식을 나머지가 0이 될때까지 반복
//나머지가 0이 되면, 나눴던 작은 수가 최대공약수가 된다.

function solution(n, m) {
  //유클리드 호제법 3가지 변수가 필요하다.
  //가장 큰 수, 가장 작은 수, 두 수를 나눴을 때의 나머지 값
  let a = m;
  let b = n;
  let r = 0;

  while (a % b > 0) {
    r = a % b;
    a = b; //큰 수에 작은 값 할당
    b = r; //작은 수에 나머지 값 할당
  }
  //최소공배수 : 두 수를 곱한 값에 최대 공약수를 나눈다
  return [b, (n * m) / b];
}
